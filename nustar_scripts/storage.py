"""Store models and data from the PyXSPEC session."""

""" 
storage.py from Pavel Medvedev (IKI, Moscow). 
2medvedev@gmail.com 
"""




import xspec
import numpy as np
import pandas as pd
import pickle
import os
class XSessionBase():
    """Base class for representing xspec session.

    The class defines an object structure, that contains
    sufficient information from the xspec session
    to be able to restore this session.

    """

    _table_list = ['params', 'fit', 'values', 'data']
    _data_columns = ['group', 'pha', 'rmf', 'arf', 'bkg', 'ignored']
    _data = pd.DataFrame(columns=_data_columns)
    _values_columns = ['val', 'delta', 'min', 'bot', 'top', 'max']
    _values = pd.DataFrame(columns=_values_columns)
    _params_columns = ['comp', 'par', 'ipar', 'val',
                       'error_l', 'error_u', 'er_status',
                       'sigma', 'frozen', 'link']
    _params = pd.DataFrame(columns=_params_columns)
    _fit_columns = ['n_gr', 'n_spec', 'statistic', 'dof', 'statMethod',
                    'weight', 'method', 'abund', 'xsect', 'bayes', 'mcmc']
    _fit = pd.DataFrame(columns=_fit_columns)

    def __init__(self):
        raise NotImplementedError()

    @property
    def values(self):
        """Write protected attribute."""
        return self._values.copy()

    @property
    def data(self):
        """Write protected attribute."""
        return self._data.copy()

    @property
    def fit(self):
        """Write protected attribute."""
        return self._fit.copy()

    @property
    def params(self):
        """Write protected attribute."""
        return self._params.copy()

    def _repr_html_(self):
        return self.params._repr_html_()


class Container(XSessionBase):
    """Container for xspec session data.

    The class provides methods for converting model and
    data information from the current PyXSPEC session
    to ``pandas.DataFrame`` tables. Similar to 'xcm' files
    generated by 'save all' command, class object can be used to
    restore xspec session.

    Attributes
    ----------
    params : ``pandas.DataFrame``
    Table with best-fit parameters, errors, links, etc.
    values : ``pandas.DataFrame``
    Table with parameter values --- 'val','delta','min','bot','top','max'
    fit : ``pandas.DataFrame``
    Table with fit statistic, method, dof etc.
    data : ``pandas.DataFrame``
    Table with pathes to data files, rmf, arf etc.
    model : str
    xspec model expression

    """

    def __init__(self, srcID=None):
        """Initialize en empty object."""
        self.srcID = srcID
        self.group = None
        self._model = None
        self.data_dir = None
        self.replace_model = None
        self.replace_data = None
        self.verbose = False

    @property
    def data(self):
        """Write-protected property."""
        if self.replace_data is None:
            return self._data.copy()
        else:
            old, new = next(iter(self.replace_data.items()))
            return self._data.copy().replace(old, new, regex=True)

    @property
    def model(self):
        """Write-protected property."""
        if self.replace_model is None:
            return self._model
        else:
            old, new = next(iter(self.replace_model.items()))
            return self._model.replace(old, new)

    @property
    def vprint(self):
        if self.verbose:
            return print
        else:
            return lambda x: None

    def __repr__(self):
        """Print all tables."""
        class_name = self.__class__.__name__
        full_str = f'<{class_name} with ObsID {self.srcID}>'
        return full_str

    def get_session(self, group=1):
        """Grab all data from the current PyXspec session."""
        self.group = group
        self._model = xspec.AllModels(group).expression

        for attr in Container._table_list:
            self.xdata2table(table=attr)

        return self

    def xdata2table(self, table):
        """Get data from xspec session and convert in to table.

        Availible tables are in the _table_list class attribute.
        """

        if table == 'data':
            """Get data pathes."""
            nspec = xspec.AllData.nSpectra
            if nspec > 0:
                rows = []
                for n in range(1, nspec + 1):
                    spec = xspec.AllData(n)
                    if spec.dataGroup == self.group:
                        row = [self.group, os.path.abspath(spec.fileName),
                               os.path.abspath(spec.response.rmf),
                               os.path.abspath(spec.response.arf)]
                        try:
                            bkg = spec.background.fileName
                            row += [os.path.abspath(bkg), ]
                        except Exception:
                            row += ['', ]
                        row += [spec.ignoredString(), ]
                    else:
                        # added by SB for nustar, when data is loaded as data 1:1 FPMA.pha 2:2 FPMB:pha
                        row = ['', ]
                    rows += [row, ]
                self._data = pd.DataFrame(rows, columns=self.data.columns)
        elif table == 'values':
            """Get parameter limits for the model in a given data group."""
            if len(xspec.AllModels.sources) > 0:
                model = xspec.AllModels(self.group)
                npar = model.nParameters
                vals = np.empty([npar, 6], dtype=float)
                for i in range(npar):
                    vals[i, :] = model(i + 1).values
                self._values = pd.DataFrame(vals, columns=self.values.columns)
        elif table == 'params':
            """Get the best-fit model in a given data group."""
            if len(xspec.AllModels.sources) > 0:
                model = xspec.AllModels(self.group)
                rows = []
                for comp_name in model.componentNames:
                    comp = getattr(model, comp_name)
                    for par_name in comp.parameterNames:
                        par = getattr(comp, par_name)
                        row = [''.join(comp_name.split()), ]
                        row += [''.join(par_name.split()), ]
                        row += [par.index, par.values[0],
                                par.error[0], par.error[1], par.error[2], ]
                        row += [par.sigma, par.frozen, par.link, ]
                        rows += [row, ]
                self._params = pd.DataFrame(rows, columns=self.params.columns)
        elif table == 'fit':
            """Get fit statistic."""
            row = [xspec.AllData.nGroups, xspec.AllData.nSpectra, ]
            row += [xspec.Fit.statistic, xspec.Fit.dof, xspec.Fit.statMethod, ]
            row += [xspec.Fit.weight, xspec.Fit.method,
                    xspec.Xset.abund, xspec.Xset.xsect, ]
            row += [xspec.Fit.bayes, ]
            try:
                mcmc = xspec.AllChains(1).fileName
            except Exception:
                mcmc = ''
            row += [mcmc, ]
            self._fit = pd.DataFrame([row, ], columns=self.fit.columns)
        else:
            raise ValueError(
                f"Unknown data attribute. Available: 'model', 'data', 'params', 'values', 'fit'. Got: {table}")

    def restore_model(self):
        if (self.model is not None) and (self.values is not None) and (self.params is not None):
            xspec.AllModels.clear()
            # I. Restore model
            model = xspec.Model(self.model)
            self.vprint('Setting parameter values...')
            newPars = {line[0] + 1: ' '.join(str(x) for x in line[1:])
                       for line in self.values.itertuples()}
            model.setPars(newPars)
            self.vprint('Done')
            self.vprint('Setting parameter links...')
            newLinks = {
                line[0] + 1: line.link for line in self.params.itertuples() if line.link != ''}
            model.setPars(newLinks)
            self.vprint('Done')
            self.vprint('Freezing parameters...')
            for i in range(model.nParameters):
                ifroz = self.params.frozen.iloc[i]
                if ifroz != model(i + 1).frozen:
                    model(i + 1).frozen = ifroz
            self.vprint('Done')

    def set_ignore(self):
        for line in self.data.itertuples():
            if line.ignored:
                spec = xspec.AllData(line.Index + 1)
                spec.ignore(line.ignored)

    def restore_data(self, ogip_type=1):
        if ogip_type != 1:
            raise NotImplementedError()

        if self.data is not None:
            xspec.AllData.clear()
            self.vprint('Loading data...')
            for line in self.data.itertuples():
                pha = {'pha': line.pha, 'rmf': line.rmf,
                       'arf': line.arf, 'bkg': line.bkg}
                spec = load_one_spec(pha)
                if line.ignored:
                    spec.ignore(line.ignored)
            self.vprint('Done')
            mcmc = self.fit.mcmc.values[0]
            if mcmc != '' and os.path.isfile(mcmc):
                self.vprint('Loading MCMC...')
                xspec.AllChains.clear()
                xspec.AllChains += self.fit['mcmc'].values[0]
            self.vprint('Restore complete')

    def restore(self):
        """Restore PyXSPEC session from object data."""
        self.restore_model()
        self.restore_data()


class Storage(XSessionBase):
    """Storage for Container class objects."""

    def __init__(self, item=None):
        """Create en empty storage."""
        self._nitems = 0
        self._srcID = []
        self._model = []
        self.replace_model = None
        self.replace_data = None
        if item is not None:
            self.__call__(item)

    def __call__(self, item):
        """Put container to the storage."""
        if hasattr(item, 'srcID'):
            self.add_container(item)
        elif hasattr(item, '_srcID'):
            raise NotImplementedError(5 * '*' + 'TODO' + 5 * '*')
            self.add_storage(item)
        else:
            raise TypeError(
                f'Input must be a Storage or Container object, got: {type(item)}')

    def __repr__(self):
        class_name = self.__class__.__name__
        return f'<{class_name} with {self._nitems} containers>'

    def __len__(self):
        return self._nitems

    def __getitem__(self, key):
        """Get container from the storage."""
        if isinstance(key, slice):
            # idxes = [range(*key.indices(len(self)))]
            raise NotImplementedError(5 * '*' + 'TODO' + 5 * '*')
        elif isinstance(key, int):
            # Since added Container objects are not stored in the storage, but
            # appended to the tables of _table_list, we need to make new Container
            # object to get an item of the Storage object.
            container = Container()
            container.srcID = self._srcID[key]
            container._model = self._model[key]
            for attr in Storage._table_list:
                table = getattr(self, attr)
                item_table = table.loc[table.N == key]
                item_table = item_table.drop(columns=['N', 'srcID'])
                item_table = item_table.reset_index(drop=True)
                setattr(container, '_' + attr, item_table)
            container.replace_model = self.replace_model
            container.replace_data = self.replace_data
        return container

    @classmethod
    def from_pikle(cls, name):
        """Construct class object from pickle (made by to_pickle method)."""
        with open(name, "rb") as file:
            data = pickle.load(file)
        if isinstance(data, dict):
            obj = cls()
            for attr in cls._table_list:
                obj.append_table(attr, data[attr])
            obj._nitems += data['nitems']
            obj._srcID += data['srcID']
            obj._model += data['model']
            return obj
        else:
            raise TypeError(
                f'Unable to restore storage from pickle: unknown type `{type(data)}`')

    def to_pickle(self, name):
        """Save storage to pickle format as a dictionary."""
        with open(name, "wb") as file:
            data = {}
            for attr in Storage._table_list:
                data[attr] = getattr(self, attr)
            data['srcID'] = self._srcID
            data['nitems'] = self._nitems
            data['model'] = self._model
            pickle.dump(data, file)

    def append_table(self, attr_name, df):
        attr = getattr(self, attr_name)
        if len(attr) == 0:
            setattr(self, '_' + attr_name, df)
        else:
            #setattr(self, '_' + attr_name, attr.append(df, ignore_index=True))
            setattr(self, '_' + attr_name, pd.concat([attr, df], ignore_index=True))

    def add_container(self, container):
        """Append XSession object to the Storage object."""
        for attr in Storage._table_list:
            container_table = getattr(container, attr)
            if container_table is not None:
                container_table.insert(
                    0, column='srcID', value=container.srcID)
                container_table.insert(0, column='N', value=self._nitems)
                self.append_table(attr, container_table)
            else:
                raise ValueError(
                    f"Couldn't add container with None table `{attr}`")
        self._nitems += 1
        self._srcID += [container.srcID, ]
        self._model += [container.model, ]


def load_one_spec(pha, new_group=False):
    """Load one pha-file with rmf, arf and bkg files.

    Parameters
    ----------
    pha : dict or str
    Dict: A dictionary with required key 'pha' with path to pha file,
    and optional keys 'rmf', 'arf' and 'bkg'. If optional keys
    are not set, then it looks for them at the same dir. If they
    are set to None, then it is not used. Str: path to pha-file

    new_group : bool
    Whether add new spectrum to the new data group or put
    it to the current data group.

    """
    if isinstance(pha, str):
        pha = {'pha': pha}

    # a workaround to prevent `Error: cannot read response ...` msg
    # that will arise when loading spectrum due to relative path
    # in the fits header
    current_dir = os.getcwd()
    data_dir = os.path.dirname(pha['pha'])
    if data_dir:
        os.chdir(data_dir)

    nS = xspec.AllData.nSpectra + 1
    nG = xspec.AllData.nGroups + 1 if new_group else xspec.AllData.nGroups

    if nS == 1:
        spec = xspec.Spectrum(pha['pha'])
    else:
        xspec.AllData(f"{nG}:{nS} {pha['pha']}")
        spec = xspec.AllData(nS)

    for key in ['rmf', 'arf', 'bkg']:
        if key in pha:
            if pha[key] is not None:
                if key == 'rmf':
                    spec.response = pha['rmf']
                elif key == 'arf':
                    spec.response.arf = pha['arf']
                elif key == 'bkg':
                    spec.background = pha['bkg']
        else:
            # check if there is a file with the same name in the data dir
            file_key = os.path.splitext(pha['pha'])[0] + '.' + key
            if os.path.isfile(file_key):
                if key == 'rmf':
                    spec.response = file_key
                elif key == 'arf':
                    spec.response.arf = file_key
                elif key == 'bkg':
                    spec.background = file_key
    if data_dir:
        os.chdir(current_dir)
    return spec
